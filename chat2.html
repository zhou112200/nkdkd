<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>E2EE èŠå¤©å®¤</title>
  <style>
    body {
      font-family: sans-serif;
      background: #f5f5f5;
      display: flex;
      flex-direction: column;
      height: 100vh;
      margin: 0;
    }
    #chat {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }
    .msg {
      display: inline-block;
      padding: 8px 12px;
      border-radius: 16px;
      margin: 5px;
      max-width: 70%;
      word-wrap: break-word;
    }
    .me {
      background-color: #DCF8C6;
      align-self: flex-end;
    }
    .other {
      background-color: #fff;
      border: 1px solid #ccc;
      align-self: flex-start;
    }
    #controls {
      display: flex;
      padding: 10px;
      background: #fff;
      border-top: 1px solid #ddd;
    }
    #msg {
      flex: 1;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 16px;
      outline: none;
    }
    button {
      margin-left: 10px;
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      background: #4CAF50;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
    }
    button:hover {
      background: #45a049;
    }
  </style>
</head>
<body>
  <h2 style="text-align:center;margin:10px 0;">ç«¯åˆ°ç«¯åŠ å¯†èŠå¤©å®¤</h2>
  <div>
    <button onclick="createRoom()">ç”Ÿæˆä¸€æ¬¡æ€§å¯†ç </button>
    <input id="password" placeholder="è¾“å…¥æˆ¿é—´å¯†ç ">
    <button onclick="joinRoom()">åŠ å…¥</button>
  </div>
  <div id="chat"></div>
  <div id="controls">
    <input id="msg" placeholder="è¾“å…¥æ¶ˆæ¯...">
    <button onclick="sendMsg()">å‘é€</button>
  </div>

<script>
const chat = document.getElementById("chat");
let ws, myKeyPair, sharedKey, peerPubKey;
const enc = new TextEncoder(), dec = new TextDecoder();

// ğŸ”¹ ä¸€æ¬¡æ€§å¯†ç ç”Ÿæˆ
function generateRoomPassword() {
  const array = new Uint8Array(16);
  crypto.getRandomValues(array);
  return btoa(String.fromCharCode(...array));
}

function createRoom() {
  const pw = generateRoomPassword();
  alert("åˆ†äº«ç»™å¯¹æ–¹çš„ä¸€æ¬¡æ€§å¯†ç ï¼š\n" + pw);
  document.getElementById("password").value = pw;
}

// ğŸ”¹ åŠ å…¥æˆ¿é—´
async function joinRoom() {
  const roomPassword = document.getElementById("password").value.trim();
  if (!roomPassword) return alert("è¯·è¾“å…¥æˆ¿é—´å¯†ç ");

  ws = new WebSocket("wss://crimson-sunset-34ff.zhoujingheng79.workers.dev");

  myKeyPair = await crypto.subtle.generateKey(
    { name: "ECDH", namedCurve: "P-256" },
    true,
    ["deriveKey", "deriveBits"]
  );

  const pubKeyRaw = new Uint8Array(await crypto.subtle.exportKey("raw", myKeyPair.publicKey));

  ws.addEventListener("open", () => {
    ws.send(JSON.stringify({ type: "pubkey", key: Array.from(pubKeyRaw), pw: roomPassword }));
  });

  ws.onmessage = async (event) => {
    const msg = JSON.parse(event.data);

    // ğŸ”¹ æ¥æ”¶å¯¹æ–¹å…¬é’¥å¹¶å»ºç«‹å…±äº«å¯†é’¥
    if (msg.type === "pubkey" && !sharedKey) {
      peerPubKey = await crypto.subtle.importKey(
        "raw",
        new Uint8Array(msg.key),
        { name: "ECDH", namedCurve: "P-256" },
        true,
        []
      );

      const bits = await crypto.subtle.deriveBits(
        { name: "ECDH", public: peerPubKey },
        myKeyPair.privateKey,
        256
      );

      const mixInput = new Uint8Array([...new Uint8Array(bits), ...enc.encode(roomPassword)]);
      const baseKey = await crypto.subtle.importKey("raw", mixInput, "PBKDF2", false, ["deriveKey"]);

      sharedKey = await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: enc.encode("chat-salt"), iterations: 100000, hash: "SHA-256" },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );

      console.log("å…±äº«å¯†é’¥å»ºç«‹å®Œæˆ âœ…");
    }

    // ğŸ”¹ æ”¶åˆ°å¯¹æ–¹æ¶ˆæ¯
    if (msg.type === "chat" && sharedKey) {
      try {
        const iv = new Uint8Array(msg.payload.iv);
        const data = new Uint8Array(msg.payload.data);
        const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, sharedKey, data);
        const text = dec.decode(decrypted);
        addOtherMsg(text);
      } catch (e) {
        console.error("è§£å¯†å¤±è´¥", e);
      }
    }
  };
}

// ğŸ”¹ æ˜¾ç¤ºæ¶ˆæ¯æ°”æ³¡
function addMyMsg(text) {
  const div = document.createElement("div");
  div.className = "msg me";
  div.textContent = text;
  chat.appendChild(div);
  chat.scrollTop = chat.scrollHeight;
}
function addOtherMsg(text) {
  const div = document.createElement("div");
  div.className = "msg other";
  div.textContent = text;
  chat.appendChild(div);
  chat.scrollTop = chat.scrollHeight;
}

// ğŸ”¹ å‘é€æ¶ˆæ¯
async function sendMsg() {
  if (!sharedKey) return alert("å¯†é’¥å°šæœªå»ºç«‹");

  const input = document.getElementById("msg");
  const text = input.value.trim();
  if (!text) return;

  // å…ˆæœ¬åœ°æ˜¾ç¤º
  addMyMsg(text);

  // å†åŠ å¯†å‘é€
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, sharedKey, enc.encode(text));

  ws.send(JSON.stringify({
    type: "chat",
    payload: { iv: Array.from(iv), data: Array.from(new Uint8Array(encrypted)) }
  }));

  input.value = "";
}
</script>
</body>
</html>