<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>AES-GCM åŠ å¯†/è§£å¯†å·¥å…·ï¼ˆå«ä¸‹è½½ï¼‰</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f5f7fa; color:#333;
      display:flex; justify-content:center; align-items:flex-start; min-height:100vh;
      margin:0; padding:40px;}
    .container { background:#fff; border-radius:8px; padding:30px 40px; box-shadow:0 4px 10px rgba(0,0,0,0.1);
      max-width:760px; width:100%; }
    h2 { text-align:center; margin-bottom:12px; color:#444; }
    input, textarea, button { width:100%; padding:10px 12px; margin:8px 0; font-size:14px;
      border-radius:6px; border:1px solid #ccc; box-sizing:border-box; }
    textarea { resize:vertical; font-family:monospace; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
    .row > * { flex:1; min-width:120px; }
    .small { width:auto; padding:8px 10px; font-size:13px; }
    .label { font-weight:bold; margin-top:10px; display:block; }
    .note { font-size:13px; color:#666; margin-top:6px; }
    .error { color:red; font-size:13px; margin-top:8px; }
    .hint { color:#2a6; font-size:13px; margin-top:8px; }
  </style>
</head>
<body>
  <div class="container">
    <h2>ğŸ” AES-GCM åŠ å¯†/è§£å¯†å·¥å…·ï¼ˆå«ä¸‹è½½ï¼‰</h2>

    <input id="password" type="password" placeholder="è¾“å…¥å£ä»¤">

    <!-- åŠ å¯† -->
    <div class="section">
      <span class="label">æ˜æ–‡ï¼ˆå¾…åŠ å¯†ï¼‰ï¼š</span>
      <textarea id="message" rows="4" placeholder="è¾“å…¥è¦åŠ å¯†çš„æ–‡å­—"></textarea>
      <div class="row">
        <button class="small" onclick="encryptMessage()">åŠ å¯†</button>
        <button class="small" onclick="clearAll()">æ¸…ç©º</button>
      </div>

      <span class="label">åŠ å¯†ç»“æœï¼ˆBase64 å¯†æ–‡ï¼‰ï¼š</span>
      <textarea id="cipher" rows="6" readonly></textarea>
      <div class="row">
        <button class="small" onclick="copyToClipboard('cipher')">å¤åˆ¶å¯†æ–‡</button>
        <button class="small" onclick="downloadCipherText()">ä¸‹è½½ Base64 (.txt)</button>
        <button class="small" onclick="downloadCipherBinary()">ä¸‹è½½ äºŒè¿›åˆ¶ (.enc)</button>
      </div>
      <div class="note">äºŒè¿›åˆ¶æ–‡ä»¶ = salt(16) + iv(12) + cipherBytesï¼Œç”¨äºç¨‹åºåŒ–å¯¼å…¥ã€‚</div>
    </div>

    <!-- è§£å¯† -->
    <div class="section">
      <span class="label">è§£å¯†ï¼ˆç²˜è´´å¯†æ–‡æˆ–åŠ è½½ .encï¼‰ï¼š</span>
      <textarea id="cipherInput" rows="6" placeholder="ç²˜è´´å¯†æ–‡"></textarea>
      <div class="row">
        <button class="small" onclick="decryptMessage()">è§£å¯†</button>
        <button class="small" onclick="tryLoadFile()">ä»æ–‡ä»¶åŠ è½½ .enc</button>
      </div>
      <span class="label">è§£å¯†ç»“æœï¼š</span>
      <textarea id="plain" rows="4" readonly></textarea>
    </div>

    <!-- å¯¼å‡º -->
    <div class="section">
      <span class="label">å¯¼å‡º / ä¸‹è½½ å£ä»¤ä¸å¯†æ–‡ï¼ˆæ•æ„Ÿï¼ï¼‰</span>
      <div class="row">
        <button class="small" onclick="downloadPassword()">ä¸‹è½½å£ä»¤ (.txt)</button>
        <button class="small" onclick="downloadExportJSON(false)">å¯¼å‡º JSONï¼ˆä¸å«å£ä»¤ï¼‰</button>
        <button class="small" onclick="downloadExportJSON(true)">å¯¼å‡º JSONï¼ˆå«å£ä»¤ï¼Œéœ€ç¡®è®¤ï¼‰</button>
      </div>
      <div class="note">âš ï¸ å¯¼å‡ºå«å£ä»¤ä¼šæœ‰æ³„éœ²é£é™©ï¼Œè¯·è°¨æ…ã€‚</div>
    </div>

    <!-- å·¥å…· -->
    <div class="section">
      <span class="label">å·¥å…·</span>
      <div class="row">
        <button class="small" onclick="downloadExample()">ä¸‹è½½ç¤ºä¾‹å¯†æ–‡ (.enc)</button>
        <button class="small" onclick="alertAbout()">å…³äºå®‰å…¨æ€§</button>
      </div>
    </div>

    <div id="error" class="error"></div>
    <div id="hint" class="hint"></div>
    <input id="fileLoader" type="file" accept=".enc" style="display:none" />
  </div>

  <script>
    // === é…ç½® ===
    const ITERATIONS = 1000000, SALT_LEN = 16, IV_LEN = 12;
    const el = {
      password: document.getElementById("password"),
      message: document.getElementById("message"),
      cipher: document.getElementById("cipher"),
      cipherIn: document.getElementById("cipherInput"),
      plain: document.getElementById("plain"),
      error: document.getElementById("error"),
      hint: document.getElementById("hint"),
      fileLoader: document.getElementById("fileLoader")
    };

    // === å·¥å…·å‡½æ•° ===
    const ab2b64 = buf => btoa(String.fromCharCode(...new Uint8Array(buf)));
    const b642ab = base64 => {
      const bin = atob(base64);
      return Uint8Array.from(bin, c => c.charCodeAt(0)).buffer;
    };

    function showError(msg) { el.error.textContent = msg; el.hint.textContent = ""; }
    function showHint(msg) { el.hint.textContent = msg; el.error.textContent = ""; }
    function clearAllMessages() { el.error.textContent = ""; el.hint.textContent = ""; }

    function downloadBlob(filename, blob) {
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      a.click();
      URL.revokeObjectURL(a.href);
    }
    const downloadTextFile = (name, text) => downloadBlob(name, new Blob([text], { type: "text/plain" }));
    const downloadBinaryFile = (name, arr) => downloadBlob(name, new Blob([arr], { type: "application/octet-stream" }));

    async function copyToClipboard(id) {
      const text = document.getElementById(id).value;
      if (!text) return showError("æ²¡æœ‰å†…å®¹å¯å¤åˆ¶ï¼");
      try {
        await navigator.clipboard.writeText(text);
        showHint("å·²å¤åˆ¶åˆ°å‰ªè´´æ¿");
      } catch { showError("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶ã€‚"); }
    }

    async function getKey(password, salt) {
      const pwKey = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveKey"]);
      return crypto.subtle.deriveKey(
        { name: "PBKDF2", salt, iterations: ITERATIONS, hash: "SHA-256" },
        pwKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]
      );
    }

    // === æ ¸å¿ƒåŠŸèƒ½ ===
    async function encryptMessage() {
      clearAllMessages();
      el.cipher.value = ""; el.plain.value = "";
      const password = el.password.value.trim(), message = el.message.value;
      if (!password || !message) return showError("è¯·è¾“å…¥å£ä»¤å’Œæ˜æ–‡ï¼");
      try {
        const salt = crypto.getRandomValues(new Uint8Array(SALT_LEN));
        const iv = crypto.getRandomValues(new Uint8Array(IV_LEN));
        const key = await getKey(password, salt);
        const cipherBuffer = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, new TextEncoder().encode(message));
        const full = new Uint8Array(salt.length + iv.length + cipherBuffer.byteLength);
        full.set(salt); full.set(iv, salt.length); full.set(new Uint8Array(cipherBuffer), salt.length + iv.length);
        el.cipher.value = ab2b64(full.buffer);
        showHint("âœ… åŠ å¯†æˆåŠŸ");
      } catch (e) { showError("åŠ å¯†å¤±è´¥ï¼š" + e.message); }
    }

    async function decryptMessage() {
      clearAllMessages();
      el.plain.value = "";
      const password = el.password.value.trim(), cipherText = el.cipherIn.value.trim();
      if (!password || !cipherText) return showError("è¯·è¾“å…¥å£ä»¤å’Œå¯†æ–‡ï¼");
      try {
        const full = new Uint8Array(b642ab(cipherText));
        if (full.length < SALT_LEN + IV_LEN) return showError("âŒ å¯†æ–‡ä¸å®Œæ•´ï¼");
        const salt = full.slice(0, SALT_LEN), iv = full.slice(SALT_LEN, SALT_LEN + IV_LEN), data = full.slice(SALT_LEN + IV_LEN);
        const key = await getKey(password, salt);
        const plainBuffer = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, data);
        el.plain.value = new TextDecoder().decode(plainBuffer);
        showHint("âœ… è§£å¯†æˆåŠŸ");
      } catch { showError("âŒ è§£å¯†å¤±è´¥ï¼šå£ä»¤é”™è¯¯æˆ–æ•°æ®æŸå"); }
    }

    function downloadCipherText() {
      if (!el.cipher.value) return showError("æ²¡æœ‰å¯ä¸‹è½½çš„å¯†æ–‡");
      downloadTextFile(`cipher_${Date.now()}.txt`, el.cipher.value.trim());
      showHint("å·²ä¸‹è½½ Base64 å¯†æ–‡");
    }

    function downloadCipherBinary() {
      if (!el.cipher.value) return showError("æ²¡æœ‰å¯ä¸‹è½½çš„å¯†æ–‡");
      const arrBuf = b642ab(el.cipher.value.trim());
      downloadBinaryFile(`cipher_${Date.now()}.enc`, new Uint8Array(arrBuf));
      showHint("å·²ä¸‹è½½ .enc æ–‡ä»¶");
    }

    function downloadPassword() {
      const pwd = el.password.value;
      if (!pwd) return showError("è¯·è¾“å…¥å£ä»¤");
      if (!confirm("âš ï¸ å£ä»¤å±äºé«˜åº¦æ•æ„Ÿä¿¡æ¯ï¼Œç¡®å®šè¦æ˜æ–‡ä¸‹è½½å—ï¼Ÿ")) return;
      downloadTextFile(`password_${Date.now()}.txt`, pwd);
      showHint("å£ä»¤æ–‡ä»¶å·²ä¸‹è½½");
    }

    function downloadExportJSON(includePassword) {
      if (!el.cipher.value) return showError("æ²¡æœ‰å¯†æ–‡å¯å¯¼å‡º");
      if (includePassword && (!el.password.value || !confirm("âš ï¸ ç¡®è®¤å¯¼å‡ºåŒ…å«å£ä»¤ï¼Ÿ"))) return;
      const payload = {
        created_at: new Date().toISOString(),
        cipher_base64: el.cipher.value.trim(),
        contains_password: includePassword
      };
      if (includePassword) payload.password = el.password.value;
      downloadBlob(`export_${Date.now()}.json`, new Blob([JSON.stringify(payload, null, 2)], { type:"application/json" }));
      showHint("å·²å¯¼å‡º JSON æ–‡ä»¶");
    }

    function tryLoadFile() {
      el.fileLoader.value = "";
      el.fileLoader.onchange = e => {
        const f = e.target.files[0]; if (!f) return;
        const reader = new FileReader();
        reader.onload = () => { el.cipherIn.value = ab2b64(reader.result); showHint(".enc æ–‡ä»¶å·²åŠ è½½"); };
        reader.onerror = () => showError("è¯»å–æ–‡ä»¶å¤±è´¥");
        reader.readAsArrayBuffer(f);
      };
      el.fileLoader.click();
    }

    function downloadExample() {
      const salt = crypto.getRandomValues(new Uint8Array(SALT_LEN));
      const iv = crypto.getRandomValues(new Uint8Array(IV_LEN));
      const full = new Uint8Array([...salt, ...iv]);
      downloadBinaryFile(`example_${Date.now()}.enc`, full);
      showHint("ç¤ºä¾‹æ–‡ä»¶å·²ä¸‹è½½");
    }

    function alertAbout() {
      alert(`å®‰å…¨æ€§è¯´æ˜ï¼š
1. .enc æ ¼å¼ = salt(16) + iv(12) + cipherBytesã€‚
2. å«å£ä»¤å¯¼å‡ºä¼šæ³„éœ²å¯†ç ï¼Œè¯·è°¨æ…ã€‚
3. å»ºè®®åªä¿å­˜å¯†æ–‡ï¼Œå£ä»¤å­˜æ”¾äºå¯†ç ç®¡ç†å™¨ã€‚`);
    }

    function clearAll() {
      el.password.value = el.message.value = el.cipher.value = el.cipherIn.value = el.plain.value = "";
      clearAllMessages();
    }
  </script>
</body>
</html>
